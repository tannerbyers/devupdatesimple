{"ast":null,"code":"// eslint-disable-next-line no-unused-vars\nconst {\n  Picker\n} = require('selderee');\n\nconst {\n  trimCharacter\n} = require('./helper'); // eslint-disable-next-line no-unused-vars\n\n\nconst {\n  StackItem,\n  BlockStackItem,\n  TableCellStackItem,\n  TableRowStackItem,\n  TableStackItem,\n  TransformerStackItem\n} = require('./stack-item');\n\nconst {\n  tableToString\n} = require('./table-printer');\n\nconst {\n  WhitespaceProcessor\n} = require('./whitespace-processor'); // eslint-disable-next-line import/no-unassigned-import\n\n\nrequire('./typedefs');\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\n\n\nclass BlockTextBuilder {\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   * @param { Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.\n   */\n  constructor(options, picker) {\n    this.options = options;\n    this.picker = picker;\n    this.whitespaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n\n    this._wordTransformer = undefined;\n  }\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n\n\n  pushWordTransform(wordTransform) {\n    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n  }\n  /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */\n\n\n  popWordTransform() {\n    if (!this._wordTransformer) {\n      return undefined;\n    }\n\n    const transform = this._wordTransformer.transform;\n    this._wordTransformer = this._wordTransformer.next;\n    return transform;\n  }\n  /** @returns { (str: string) => string } */\n\n\n  _getCombinedWordTransformer() {\n    const applyTransformer = (str, transformer) => transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;\n\n    return str => applyTransformer(str, this._wordTransformer);\n  }\n\n  _popStackItem() {\n    const item = this._stackItem;\n    this._stackItem = item.next;\n    return item;\n  }\n  /**\n   * Add a line break into currently built block.\n   */\n\n\n  addLineBreak() {\n    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {\n      return;\n    }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += '\\n';\n    } else {\n      this._stackItem.inlineTextBuilder.startNewLine();\n    }\n  }\n  /**\n   * Allow to break line in case directly following text will not fit.\n   */\n\n\n  addWordBreakOpportunity() {\n    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem) {\n      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n    }\n  }\n  /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object | boolean } [ optionsObjectOrNoWordTransform ]\n   * Object holding the parameters of the operation.\n   *\n   * Boolean value is deprecated.\n   *\n   * @param { boolean } [ optionsObjectOrNoWordTransform.noWordTransform = false ]\n   * Ignore word transformers if there are any.\n   */\n\n\n  addInline(str) {\n    let optionsObjectOrNoWordTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof optionsObjectOrNoWordTransform === 'object') {\n      this._addInline(str, optionsObjectOrNoWordTransform);\n    } else {\n      this._addInline(str, {\n        noWordTransform: optionsObjectOrNoWordTransform\n      });\n    }\n  }\n\n  _addInline(str) {\n    let {\n      noWordTransform = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {\n      return;\n    }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n\n    if (str.length === 0 || // empty string\n    this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant\n    !this.whitespaceProcessor.testContainsWords(str) // no words to add\n    ) {\n      return;\n    }\n\n    if (this.options.preserveNewlines) {\n      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);\n\n      if (newlinesNumber > 0) {\n        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber); // keep stashedLineBreaks unchanged\n\n\n        return;\n      }\n    }\n\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n\n    this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, this._wordTransformer && !noWordTransform ? this._getCombinedWordTransformer() : undefined);\n    this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n  }\n  /**\n   * Start building a new block.\n   *\n   * @param { object | number } [optionsObjectOrLeadingLineBreaks]\n   * Object holding the parameters of the block.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number }  [optionsObjectOrLeadingLineBreaks.leadingLineBreaks = 1]\n   * This block should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number }  [optionsObjectOrLeadingLineBreaks.reservedLineLength = 0]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [optionsObjectOrLeadingLineBreaks.isPre = false]\n   * Should HTML whitespace be preserved inside this block.\n   *\n   * @param { number }  [reservedLineLength]\n   * Deprecated.\n   *\n   * @param { boolean } [isPre]\n   * Deprecated.\n   */\n\n\n  openBlock() {\n    let optionsObjectOrLeadingLineBreaks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let reservedLineLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let isPre = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n    if (typeof optionsObjectOrLeadingLineBreaks === 'object') {\n      this._openBlock(optionsObjectOrLeadingLineBreaks);\n    } else {\n      this._openBlock({\n        isPre: isPre,\n        leadingLineBreaks: optionsObjectOrLeadingLineBreaks,\n        reservedLineLength: reservedLineLength\n      });\n    }\n  }\n\n  _openBlock() {\n    let {\n      leadingLineBreaks = 1,\n      reservedLineLength = 0,\n      isPre = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n    this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);\n\n    if (isPre) {\n      this._stackItem.isPre = true;\n    }\n  }\n  /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object | number }         [optionsObjectOrTrailingLineBreaks]\n   * Object holding the parameters of the block.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number }                  [optionsObjectOrTrailingLineBreaks.trailingLineBreaks = 1]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [optionsObjectOrTrailingLineBreaks.blockTransform = undefined]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   *\n   * @param { (str: string) => string } [blockTransform]\n   * Deprecated.\n   */\n\n\n  closeBlock() {\n    let optionsObjectOrTrailingLineBreaks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let blockTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n    if (typeof optionsObjectOrTrailingLineBreaks === 'object') {\n      this._closeBlock(optionsObjectOrTrailingLineBreaks);\n    } else {\n      this._closeBlock({\n        trailingLineBreaks: optionsObjectOrTrailingLineBreaks,\n        blockTransform: blockTransform\n      });\n    }\n  }\n\n  _closeBlock() {\n    let {\n      trailingLineBreaks = 1,\n      blockTransform = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const block = this._popStackItem();\n\n    const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);\n    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n  }\n  /**\n   * Start building a table.\n   */\n\n\n  openTable() {\n    this._stackItem = new TableStackItem(this._stackItem);\n  }\n  /**\n   * Start building a table row.\n   */\n\n\n  openTableRow() {\n    if (!(this._stackItem instanceof TableStackItem)) {\n      throw new Error('Can\\'t add table row to something that is not a table! Check the formatter.');\n    }\n\n    this._stackItem = new TableRowStackItem(this._stackItem);\n  }\n  /**\n   * Start building a table cell.\n   *\n   * @param { object | number } [optionsObjectOrMaxColumnWidth = undefined]\n   * Object holding the parameters of the cell.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrMaxColumnWidth.maxColumnWidth = undefined]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */\n\n\n  openTableCell() {\n    let optionsObjectOrMaxColumnWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (typeof optionsObjectOrMaxColumnWidth === 'object') {\n      this._openTableCell(optionsObjectOrMaxColumnWidth);\n    } else {\n      this._openTableCell({\n        maxColumnWidth: optionsObjectOrMaxColumnWidth\n      });\n    }\n  }\n\n  _openTableCell() {\n    let {\n      maxColumnWidth = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!(this._stackItem instanceof TableRowStackItem)) {\n      throw new Error('Can\\'t add table cell to something that is not a table row! Check the formatter.');\n    }\n\n    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n  }\n  /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object | number } [optionsObjectOrColspan]\n   * Object holding the parameters of the cell.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrColspan.colspan = 1] How many columns this cell should occupy.\n   * @param { number } [optionsObjectOrColspan.rowspan = 1] How many rows this cell should occupy.\n   *\n   * @param { number } [rowspan] Deprecated.\n   */\n\n\n  closeTableCell() {\n    let optionsObjectOrColspan = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let rowspan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n    if (typeof optionsObjectOrColspan === 'object') {\n      this._closeTableCell(optionsObjectOrColspan);\n    } else {\n      this._closeTableCell({\n        colspan: optionsObjectOrColspan,\n        rowspan: rowspan\n      });\n    }\n  }\n\n  _closeTableCell() {\n    let {\n      colspan = 1,\n      rowspan = 1\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const cell = this._popStackItem();\n\n    const text = trimCharacter(getText(cell), '\\n');\n    cell.next.cells.push({\n      colspan: colspan,\n      rowspan: rowspan,\n      text: text\n    });\n  }\n  /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */\n\n\n  closeTableRow() {\n    const row = this._popStackItem();\n\n    row.next.rows.push(row.cells);\n  }\n  /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object | number } [optionsObjectOrColSpacing]\n   * Object holding the parameters of the table.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrColSpacing.colSpacing = 3]\n   * Number of spaces between table columns.\n   *\n   * @param { number } [optionsObjectOrColSpacing.rowSpacing = 0]\n   * Number of empty lines between table rows.\n   *\n   * @param { number } [optionsObjectOrColSpacing.leadingLineBreaks = 2]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [optionsObjectOrColSpacing.trailingLineBreaks = 2]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { number } [rowSpacing]\n   * Deprecated.\n   *\n   * @param { number } [leadingLineBreaks]\n   * Deprecated.\n   *\n   * @param { number } [trailingLineBreaks]\n   * Deprecated.\n   */\n\n\n  closeTable() {\n    let optionsObjectOrColSpacing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let rowSpacing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let leadingLineBreaks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    let trailingLineBreaks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n    if (typeof optionsObjectOrColSpacing === 'object') {\n      this._closeTable(optionsObjectOrColSpacing);\n    } else {\n      this._closeTable({\n        colSpacing: optionsObjectOrColSpacing,\n        leadingLineBreaks: leadingLineBreaks,\n        rowSpacing: rowSpacing,\n        trailingLineBreaks: trailingLineBreaks\n      });\n    }\n  }\n\n  _closeTable() {\n    let {\n      colSpacing = 3,\n      rowSpacing = 0,\n      leadingLineBreaks = 2,\n      trailingLineBreaks = 2\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const table = this._popStackItem();\n\n    const output = tableToString(table.rows, rowSpacing, colSpacing);\n\n    if (output) {\n      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n  /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */\n\n\n  toString() {\n    return getText(this._stackItem.getRoot()); // There should only be the root item if everything is closed properly.\n  }\n\n}\n\nfunction getText(stackItem) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks and table cells can be requested for text contents.');\n  }\n\n  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\n\nfunction addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks and table cells can contain text.');\n  }\n\n  const parentText = getText(stackItem);\n  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n\nmodule.exports = {\n  BlockTextBuilder: BlockTextBuilder\n};","map":{"version":3,"sources":["/Users/tbyers/fun/devupdatesimple/client/node_modules/html-to-text/lib/block-text-builder.js"],"names":["Picker","require","trimCharacter","StackItem","BlockStackItem","TableCellStackItem","TableRowStackItem","TableStackItem","TransformerStackItem","tableToString","WhitespaceProcessor","BlockTextBuilder","constructor","options","picker","whitespaceProcessor","_stackItem","_wordTransformer","undefined","pushWordTransform","wordTransform","popWordTransform","transform","next","_getCombinedWordTransformer","applyTransformer","str","transformer","_popStackItem","item","addLineBreak","isPre","rawText","inlineTextBuilder","startNewLine","addWordBreakOpportunity","wordBreakOpportunity","addInline","optionsObjectOrNoWordTransform","_addInline","noWordTransform","length","stashedLineBreaks","testContainsWords","preserveNewlines","newlinesNumber","countNewlinesNoWords","shrinkWrapAdd","openBlock","optionsObjectOrLeadingLineBreaks","reservedLineLength","_openBlock","leadingLineBreaks","maxLineLength","Math","max","closeBlock","optionsObjectOrTrailingLineBreaks","blockTransform","_closeBlock","trailingLineBreaks","block","blockText","getText","addText","openTable","openTableRow","Error","openTableCell","optionsObjectOrMaxColumnWidth","_openTableCell","maxColumnWidth","closeTableCell","optionsObjectOrColspan","rowspan","_closeTableCell","colspan","cell","text","cells","push","closeTableRow","row","rows","closeTable","optionsObjectOrColSpacing","rowSpacing","_closeTable","colSpacing","table","output","toString","getRoot","stackItem","isEmpty","parentText","lineBreaks","clear","repeat","module","exports"],"mappings":"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","sourcesContent":["\n// eslint-disable-next-line no-unused-vars\nconst { Picker } = require('selderee');\n\nconst { trimCharacter } = require('./helper');\n// eslint-disable-next-line no-unused-vars\nconst { StackItem, BlockStackItem, TableCellStackItem, TableRowStackItem, TableStackItem, TransformerStackItem }\n  = require('./stack-item');\nconst { tableToString } = require('./table-printer');\nconst { WhitespaceProcessor } = require('./whitespace-processor');\n\n// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\nclass BlockTextBuilder {\n\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   * @param { Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.\n   */\n  constructor (options, picker) {\n    this.options = options;\n    this.picker = picker;\n    this.whitespaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n    this._wordTransformer = undefined;\n  }\n\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n  pushWordTransform (wordTransform) {\n    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n  }\n\n  /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */\n  popWordTransform () {\n    if (!this._wordTransformer) { return undefined; }\n    const transform = this._wordTransformer.transform;\n    this._wordTransformer = this._wordTransformer.next;\n    return transform;\n  }\n\n  /** @returns { (str: string) => string } */\n  _getCombinedWordTransformer () {\n    const applyTransformer = (str, transformer) =>\n      ((transformer) ? applyTransformer(transformer.transform(str), transformer.next) : str);\n    return (str) => applyTransformer(str, this._wordTransformer);\n  }\n\n  _popStackItem () {\n    const item = this._stackItem;\n    this._stackItem = item.next;\n    return item;\n  }\n\n  /**\n   * Add a line break into currently built block.\n   */\n  addLineBreak () {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += '\\n';\n    } else {\n      this._stackItem.inlineTextBuilder.startNewLine();\n    }\n  }\n\n  /**\n   * Allow to break line in case directly following text will not fit.\n   */\n  addWordBreakOpportunity () {\n    if (\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof TableCellStackItem\n    ) {\n      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n    }\n  }\n\n  /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object | boolean } [ optionsObjectOrNoWordTransform ]\n   * Object holding the parameters of the operation.\n   *\n   * Boolean value is deprecated.\n   *\n   * @param { boolean } [ optionsObjectOrNoWordTransform.noWordTransform = false ]\n   * Ignore word transformers if there are any.\n   */\n  addInline (str, optionsObjectOrNoWordTransform = {}) {\n    if (typeof optionsObjectOrNoWordTransform === 'object') {\n      this._addInline(str, optionsObjectOrNoWordTransform);\n    } else {\n      this._addInline(str, { noWordTransform: optionsObjectOrNoWordTransform });\n    }\n  }\n\n  _addInline (str, { noWordTransform = false } = {}) {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n\n    if (\n      str.length === 0 || // empty string\n      (\n        this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant\n        !this.whitespaceProcessor.testContainsWords(str) // no words to add\n      )\n    ) { return; }\n\n    if (this.options.preserveNewlines) {\n      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);\n      if (newlinesNumber > 0) {\n        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);\n        // keep stashedLineBreaks unchanged\n        return;\n      }\n    }\n\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n    this.whitespaceProcessor.shrinkWrapAdd(\n      str,\n      this._stackItem.inlineTextBuilder,\n      (this._wordTransformer && !noWordTransform) ? this._getCombinedWordTransformer() : undefined\n    );\n    this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n  }\n\n  /**\n   * Start building a new block.\n   *\n   * @param { object | number } [optionsObjectOrLeadingLineBreaks]\n   * Object holding the parameters of the block.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number }  [optionsObjectOrLeadingLineBreaks.leadingLineBreaks = 1]\n   * This block should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number }  [optionsObjectOrLeadingLineBreaks.reservedLineLength = 0]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [optionsObjectOrLeadingLineBreaks.isPre = false]\n   * Should HTML whitespace be preserved inside this block.\n   *\n   * @param { number }  [reservedLineLength]\n   * Deprecated.\n   *\n   * @param { boolean } [isPre]\n   * Deprecated.\n   */\n  openBlock (optionsObjectOrLeadingLineBreaks = {}, reservedLineLength = undefined, isPre = undefined) {\n    if (typeof optionsObjectOrLeadingLineBreaks === 'object') {\n      this._openBlock(optionsObjectOrLeadingLineBreaks);\n    } else {\n      this._openBlock({\n        isPre: isPre,\n        leadingLineBreaks: optionsObjectOrLeadingLineBreaks,\n        reservedLineLength: reservedLineLength,\n      });\n    }\n  }\n\n  _openBlock ({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {\n    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n    this._stackItem = new BlockStackItem(\n      this.options,\n      this._stackItem,\n      leadingLineBreaks,\n      maxLineLength\n    );\n    if (isPre) { this._stackItem.isPre = true; }\n  }\n\n  /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object | number }         [optionsObjectOrTrailingLineBreaks]\n   * Object holding the parameters of the block.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number }                  [optionsObjectOrTrailingLineBreaks.trailingLineBreaks = 1]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [optionsObjectOrTrailingLineBreaks.blockTransform = undefined]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   *\n   * @param { (str: string) => string } [blockTransform]\n   * Deprecated.\n   */\n  closeBlock (optionsObjectOrTrailingLineBreaks = {}, blockTransform = undefined) {\n    if (typeof optionsObjectOrTrailingLineBreaks === 'object') {\n      this._closeBlock(optionsObjectOrTrailingLineBreaks);\n    } else {\n      this._closeBlock({\n        trailingLineBreaks: optionsObjectOrTrailingLineBreaks,\n        blockTransform: blockTransform,\n      });\n    }\n  }\n\n  _closeBlock ({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {\n    const block = this._popStackItem();\n    const blockText = (blockTransform) ? blockTransform(getText(block)) : getText(block);\n    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n  }\n\n  /**\n   * Start building a table.\n   */\n  openTable () {\n    this._stackItem = new TableStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table row.\n   */\n  openTableRow () {\n    if (!(this._stackItem instanceof TableStackItem)) {\n      throw new Error('Can\\'t add table row to something that is not a table! Check the formatter.');\n    }\n    this._stackItem = new TableRowStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table cell.\n   *\n   * @param { object | number } [optionsObjectOrMaxColumnWidth = undefined]\n   * Object holding the parameters of the cell.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrMaxColumnWidth.maxColumnWidth = undefined]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */\n  openTableCell (optionsObjectOrMaxColumnWidth = {}) {\n    if (typeof optionsObjectOrMaxColumnWidth === 'object') {\n      this._openTableCell(optionsObjectOrMaxColumnWidth);\n    } else {\n      this._openTableCell({ maxColumnWidth: optionsObjectOrMaxColumnWidth });\n    }\n  }\n\n  _openTableCell ({ maxColumnWidth = undefined } = {}) {\n    if (!(this._stackItem instanceof TableRowStackItem)) {\n      throw new Error('Can\\'t add table cell to something that is not a table row! Check the formatter.');\n    }\n    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n  }\n\n  /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object | number } [optionsObjectOrColspan]\n   * Object holding the parameters of the cell.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrColspan.colspan = 1] How many columns this cell should occupy.\n   * @param { number } [optionsObjectOrColspan.rowspan = 1] How many rows this cell should occupy.\n   *\n   * @param { number } [rowspan] Deprecated.\n   */\n  closeTableCell (optionsObjectOrColspan = {}, rowspan = undefined) {\n    if (typeof optionsObjectOrColspan === 'object') {\n      this._closeTableCell(optionsObjectOrColspan);\n    } else {\n      this._closeTableCell({\n        colspan: optionsObjectOrColspan,\n        rowspan: rowspan,\n      });\n    }\n  }\n\n  _closeTableCell ({ colspan = 1, rowspan = 1 } = {}) {\n    const cell = this._popStackItem();\n    const text = trimCharacter(getText(cell), '\\n');\n    cell.next.cells.push({ colspan: colspan, rowspan: rowspan, text: text });\n  }\n\n  /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */\n  closeTableRow () {\n    const row = this._popStackItem();\n    row.next.rows.push(row.cells);\n  }\n\n  /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object | number } [optionsObjectOrColSpacing]\n   * Object holding the parameters of the table.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrColSpacing.colSpacing = 3]\n   * Number of spaces between table columns.\n   *\n   * @param { number } [optionsObjectOrColSpacing.rowSpacing = 0]\n   * Number of empty lines between table rows.\n   *\n   * @param { number } [optionsObjectOrColSpacing.leadingLineBreaks = 2]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [optionsObjectOrColSpacing.trailingLineBreaks = 2]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { number } [rowSpacing]\n   * Deprecated.\n   *\n   * @param { number } [leadingLineBreaks]\n   * Deprecated.\n   *\n   * @param { number } [trailingLineBreaks]\n   * Deprecated.\n   */\n  closeTable (\n    optionsObjectOrColSpacing = {},\n    rowSpacing = undefined,\n    leadingLineBreaks = undefined,\n    trailingLineBreaks = undefined\n  ) {\n    if (typeof optionsObjectOrColSpacing === 'object') {\n      this._closeTable(optionsObjectOrColSpacing);\n    } else {\n      this._closeTable({\n        colSpacing: optionsObjectOrColSpacing,\n        leadingLineBreaks: leadingLineBreaks,\n        rowSpacing: rowSpacing,\n        trailingLineBreaks: trailingLineBreaks\n      });\n    }\n  }\n\n  _closeTable ({ colSpacing = 3, rowSpacing = 0, leadingLineBreaks = 2, trailingLineBreaks = 2 } = {}) {\n    const table = this._popStackItem();\n    const output = tableToString(table.rows, rowSpacing, colSpacing);\n    if (output) {\n      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */\n  toString () {\n    return getText(this._stackItem.getRoot());\n    // There should only be the root item if everything is closed properly.\n  }\n\n}\n\nfunction getText (stackItem) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks and table cells can be requested for text contents.');\n  }\n  return (stackItem.inlineTextBuilder.isEmpty())\n    ? stackItem.rawText\n    : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\n\nfunction addText (stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks and table cells can contain text.');\n  }\n  const parentText = getText(stackItem);\n  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n\nmodule.exports = { BlockTextBuilder: BlockTextBuilder };\n"]},"metadata":{},"sourceType":"script"}